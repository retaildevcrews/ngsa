# NGSA in aks-secure-baseline infrastructure

Deploy NGSA apps on top of the aks-secure-baseline architecture.

## Prerequisites

Follow the [aks-secure-baseline](https://github.com/mspnp/aks-secure-baseline) walkthrough to setup the infrastructure.

## Infrastructure notes

> For this spike, existing resources and files from the aks-secure-baseline are reused.

- Hub network from walkthrough is in eastus2
- First spoke network from walkthrough is in eastus2
- First AKS cluster from walkthrough is in the eastus2 spoke
- `rg-bu0001a0008` resource group is for the application team
  - bu0001 is for Business Unit 0001
  - 0008 is the application ID
- flux is installed in the cluster as part of the walkthrough
  - it is in the `cluster-baseline-settings` namespace
- the aks cluster names are generated by
  - `"subRgUniqueString": "[uniqueString('aks', subscription().subscriptionId, resourceGroup().id)]",`
- private endpoint names for AKS to services have the format `nodepools-to-[RESOURCE]`
- First network spoke is nameed `vnet-spoke-BU0001A0008-00`, after the business unit and application

## Changes and Questions

- resource groups
  - aks-secure-baseline has one resource group, `rg-bu0001a0008`, for the application. NGSA uses 2. `ngsa-pre-app-rg` and `ngsa-pre-shared-rg`.
- cosmos
  - Using the default "All networks" option for cosmos.
  - Enabling a service endpoint is needed for the apps to reach cosmos with the current firewall settings.
  - **Investigate other network configuration options for cosmos?**
- flux
  - aks-secure-baseline has static files for deploying flux.
  - NGSA is currently using helm to deploy flux.
  - Added helm-operator deployment to cluster because NGSA apps use helm charts and HelmRelease resource
  - **What is a good next step here?**
    - **Continue with flux implementation for now, or start on Azure Arc implementation, or other?**
- NGSA
  - Copied chart from gitops so it could be easily modified for the spike.
  - Removed templates from the chart that are not needed. Things like certmanager and istio resources.
  - Imported images from GitHub container registry into private ACR.
  - Reduced resource limits for deployments because of default policies.
  - Using the existing key vault from aks-secure-baseline to save NGSA secrets.
  - Added simple template files for csi driver and pod identity configurations. These are applied manually to the cluster. Same for fluentbit.
  - **How to handle NGSA docker images? Keep in sync with private registry? Update policies to allow the images? Or something else?**
  - **Should NGSA resource defaults and/or azure policies be updated so a default helm install works?**
  - **Add pod identity and csi driver configs to GitOps workflow. Same for fluentbit.**
- Fluentbit
  - Using the existing key vault to save fluentbit secrets. The same key vault NGSA is using.
  - Using the Log Analytics in the Hub resource group.
  - **Is sharing key vaults like this okay? Should they be broken up by app or some other criteria?**
  - **Which log analytics should we use for custom logs?**
  - **Pods in the Daemonset fail to create in the aks-npsystem nodes. The csi driver for handling secrets is not installed on the nodes in that node pool.**

## Helpful links

- [Pod identity walkthrough](https://azure.github.io/aad-pod-identity/docs/demo/standard_walkthrough)
- [Azure key vault csi provider usage](https://azure.github.io/secrets-store-csi-driver-provider-azure/getting-started/usage)

## Commands

### Create cosmos

```bash

Imdb_Name="ngsa-pnp-spike-cosmos"
Imdb_RG="rg-bu0001a0008"
Imdb_DB="imdb"
Imdb_Col="movies"
Imdb_RW_Key="az cosmosdb keys list -n $Imdb_Name -g $Imdb_RG --query primaryMasterKey -o tsv"

az cosmosdb create -g $Imdb_RG -n $Imdb_Name
az cosmosdb sql database create -a $Imdb_Name -n $Imdb_DB -g $Imdb_RG --throughput 1000
az cosmosdb sql container create -p /partitionKey -g $Imdb_RG -a $Imdb_Name -d $Imdb_DB -n $Imdb_Col

docker run -it --rm retaildevcrew/imdb-import $Imdb_Name $(eval $Imdb_RW_Key) $Imdb_DB $Imdb_Col

# enable service endpoints for cosmos in the subnet for the AKS cluster nodes.

# subnet for AKS cluster nodes
NODES_SUBNET_NAME="snet-clusternodes"
# resource group for the initial spoke vnet
SPOKE_RG="rg-enterprise-networking-spokes"
# initial spoke vnet
SPOKE_VNET_NAME="vnet-spoke-BU0001A0008-00"

az network vnet subnet update \
   -n $NODES_SUBNET_NAME \
   -g $SPOKE_RG \
   --vnet-name $SPOKE_VNET_NAME \
   --service-endpoints Microsoft.AzureCosmosDB

```

### Flux setup

```bash

# list the cluster in the resource group and take note of the name
az aks list -g $Imdb_RG -o table
CLUSTER_NAME=<replace with a name from list>

# get access to a cluster
az aks get-credentials --resource-group $Imdb_RG --name $CLUSTER_NAME

# install flux
kubectl apply -f cluster-manifests/cluster-baseline-settings/flux.yaml

# wait for deployment to be ready
kubectl wait -n cluster-baseline-settings --for=condition=ready pod --selector=app.kubernetes.io/name=flux --timeout=90s

# import helm operator to private ACR
ACR_NAME=$(az deployment group show -g $Imdb_RG -n cluster-stamp --query properties.outputs.containerRegistryName.value -o tsv)
az acr import --source docker.io/fluxcd/helm-operator:1.2.0 -n $ACR_NAME

# add flux repo
helm repo add fluxcd https://charts.fluxcd.io

# deploy flux CRDs for helm operator
kubectl apply -f https://raw.githubusercontent.com/fluxcd/helm-operator/master/deploy/crds.yaml

# install helm operator
helm upgrade -i helm-operator fluxcd/helm-operator --wait \
--namespace cluster-baseline-settings \
--set git.ssh.secretName=flux-git-deploy \
--set helm.versions=v3 \
--set image.repository="${ACR_NAME}.azurecr.io/fluxcd/helm-operator" \
--set image.tag=1.2.0

```

### NGSA setup

```bash

# create ngsa namespace
kubectl create namespace ngsa

# set ngsa secrets in key vault

# set the key vault name and AKS variable names
export KEYVAULT_NAME=<key vault name>
export AKS_NAME=<aks cluster name>

# Example values that were auto generated during the initial aks-secure-baseline setup
# export KEYVAULT_NAME="kv-aks-ioxqpbmcqokqq"
# export AKS_NAME="aks-ioxqpbmcqokqq"

az keyvault secret set -o table --vault-name $KEYVAULT_NAME --name "CosmosDatabase" --value $Imdb_DB
az keyvault secret set -o table --vault-name $KEYVAULT_NAME --name "CosmosCollection" --value $Imdb_Col
az keyvault secret set -o table --vault-name $KEYVAULT_NAME --name "CosmosKey" \
  --value $(az cosmosdb keys list -n $Imdb_Name -g $Imdb_RG --query primaryReadonlyMasterKey -o tsv)
az keyvault secret set -o table --vault-name $KEYVAULT_NAME --name "CosmosUrl" --value https://${Imdb_Name}.documents.azure.com:443/

# create managed identity for NGSA
export NGSA_MI_NAME=<managed identity name for NGSA>

# Example name following naming conventions from /docs/NamingConvention.md
# export NGSA_MI_NAME="ngsa-id"

az identity create -g $Imdb_RG -n $NGSA_MI_NAME

export NGSA_MI_PRINCIPAL_ID=$(az identity show -n $NGSA_MI_NAME -g $Imdb_RG --query "principalId" -o tsv)
export NGSA_MI_RESOURCE_ID=$(az identity show -n $NGSA_MI_NAME -g $Imdb_RG --query "id" -o tsv)
export NGSA_MI_CLIENT_ID=$(az identity show -n $NGSA_MI_NAME -g $Imdb_RG --query "clientId" -o tsv)

# give the AKS node managed identity control of ngsa managed identity
AKS_IDENTITY_ID=$(az aks show -g $Imdb_RG -n $AKS_NAME --query "identityProfile.kubeletidentity.objectId" -o tsv)
az role assignment create --role "Managed Identity Operator" --assignee $AKS_IDENTITY_ID --scope $NGSA_MI_RESOURCE_ID

# give the ngsa managed identity read access to keyvault
az keyvault set-policy -n $KEYVAULT_NAME --object-id $NGSA_MI_PRINCIPAL_ID --secret-permissions get

export TENANT_ID=$(az account show --query "tenantId" -o tsv)

# manually apply pod identity configs to cluster
envsubst < ngsa-pod-identity-template.yaml | kubectl apply -n ngsa -f -

# manually apply csi configs for key vault integration to cluster
envsubst < ngsa-csi-template.yaml | kubectl apply -n ngsa -f -

# import images to private acr to allow cluser to pull images
az acr import --source ghcr.io/retaildevcrews/ngsa-app:beta -n $ACR_NAME
az acr import --source ghcr.io/retaildevcrews/ngsa-lr:beta -n $ACR_NAME

```

### Fluentbit setup

```bash

# create fluentbit namespace
kubectl create namespace fluentbit

# Choose one of the log analytics instances in the aks-secure-baseline architecture to send logs to.
Ngsa_Log_Analytics_RG=<log analytics resource group>
Ngsa_Log_Analytics_Name=<log analytics name>

# Example:
#   This will choose the log analytics in the hub resource group that was created during the spike.
#   Your log analytics name may be different.
# Ngsa_Log_Analytics_RG="rg-enterprise-networking-hubs"
# Ngsa_Log_Analytics_Name="la-hub-eastus2-lq7hlzxsovd4c"

# set fluentbit secrets in key vault
az keyvault secret set -o table --vault-name $KEYVAULT_NAME --name "WorkspaceId" \
  --value $(az monitor log-analytics workspace show -g $Ngsa_Log_Analytics_RG -n $Ngsa_Log_Analytics_Name --query customerId -o tsv)
az keyvault secret set -o table --vault-name $KEYVAULT_NAME --name "SharedKey" \
  --value $(az monitor log-analytics workspace get-shared-keys -g $Ngsa_Log_Analytics_RG -n $Ngsa_Log_Analytics_Name --query primarySharedKey -o tsv)

# create managed identity for fluentbit
export FLUENTBIT_MI_NAME=<managed identity name for fluentbit>

# Example name following naming conventions from /docs/NamingConvention.md
# export FLUENTBIT_MI_NAME="fluentbit-id"

az identity create -g $Imdb_RG -n $FLUENTBIT_MI_NAME

export FLUENTBIT_MI_PRINCIPAL_ID=$(az identity show -n $FLUENTBIT_MI_NAME -g $Imdb_RG --query "principalId" -o tsv)
export FLUENTBIT_MI_RESOURCE_ID=$(az identity show -n $FLUENTBIT_MI_NAME -g $Imdb_RG --query "id" -o tsv)
export FLUENTBIT_MI_CLIENT_ID=$(az identity show -n $FLUENTBIT_MI_NAME -g $Imdb_RG --query "clientId" -o tsv)

# give the AKS node managed identity control of fluentbit managed identity
az role assignment create --role "Managed Identity Operator" --assignee $AKS_IDENTITY_ID --scope $FLUENTBIT_MI_RESOURCE_ID

# give the fluentbit managed identity read access to keyvault
az keyvault set-policy -n $KEYVAULT_NAME --object-id $FLUENTBIT_MI_PRINCIPAL_ID --secret-permissions get

# manually apply pod identity configs to cluster
envsubst < fluentbit-pod-identity-template.yaml | kubectl apply -n fluentbit -f -

# manually apply csi configs for key vault integration to cluster
envsubst < fluentbit-csi-template.yaml | kubectl apply -n fluentbit -f -

# import images to private acr to allow cluser to pull images
az acr import --source docker.io/fluent/fluent-bit:1.5-debug -n $ACR_NAME

```
